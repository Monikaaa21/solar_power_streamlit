# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WLKh-bi6rZRRTSrkMxzNLbm9DMXcTdjg
"""

import streamlit as st
import pandas as pd
import numpy as np

# ---------------- PAGE CONFIG ----------------
st.set_page_config(
    page_title="Solar Power Prediction",
    page_icon="☀️",
    layout="centered"
)

# ---------------- DARK AESTHETIC THEME ----------------
st.markdown(
    """
    <style>
    .stApp {
        background-color: #0E1117;
        color: #EAEAEA;
    }
    h1, h2, h3 {
        color: #F5C518;
        text-align: center;
    }
    .stMarkdown, .stCaption {
        color: #CFCFCF;
    }
    .stButton > button {
        background-color: #F5C518;
        color: #0E1117;
        border-radius: 8px;
        height: 3em;
        font-size: 15px;
        font-weight: 600;
    }
    .stSlider > label {
        color: #EAEAEA;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# ---------------- TITLE ----------------
st.title("Solar Power Prediction")
st.caption("Machine Learning–based Solar Energy Forecasting")

# ---------------- SOLAR IMAGE ----------------
st.image(
    "https://images.unsplash.com/photo-1508514177221-188b1cf16e9d",
    width=800
)

# ---------------- FILE UPLOAD ----------------
uploaded_file = st.file_uploader(
    "Upload Solar Power Dataset (CSV)",
    type=["csv"]
)

# ---------------- UNIT MAPPING ----------------
UNIT_MAP = {
    "humidity": "%",
    "wind_direction": "degrees",
    "average_wind_speed": "m/s",
    "pressure": "hPa",
    "average_pressure": "hPa",
    "distance_to_solar_noon": "radians",
    "sky_cover": "scale (0–4)",
    "power": "kW"
}

# ---------------- VARIABLES TO REMOVE ----------------
REMOVE_COLUMNS = [
    "wind_speed",
    "visibility",
    "temperature"
]

if uploaded_file is not None:

    df = pd.read_csv(uploaded_file)

    # ---------------- TARGET COLUMN AUTO-DETECTION ----------------
    possible_targets = [c for c in df.columns if "power" in c.lower()]

    if not possible_targets:
        st.error("No power-related target column found in the dataset.")
        st.stop()

    TARGET_COLUMN = possible_targets[0]
    target_unit = UNIT_MAP.get("power", "units")

    # ---------------- TARGET VARIABLE SLICER ----------------
    st.subheader("Observed Power Generation Level")
    st.write(f"Detected Target Column: **{TARGET_COLUMN} ({target_unit})**")

    st.slider(
        f"Power Generation ({target_unit})",
        min_value=float(df[TARGET_COLUMN].min()),
        max_value=float(df[TARGET_COLUMN].max()),
        value=float(df[TARGET_COLUMN].mean())
    )

    # ---------------- INPUT FEATURES (AFTER REMOVAL) ----------------
    X = df.drop(columns=[TARGET_COLUMN], errors="ignore")

    X = X.drop(
        columns=[col for col in X.columns if col.lower() in REMOVE_COLUMNS],
        errors="ignore"
    ).select_dtypes(include=np.number)

    y = df[TARGET_COLUMN]

    if X.shape[1] == 0:
        st.error("No valid numeric input features available after filtering.")
        st.stop()

    X = X.fillna(X.mean())
    y = y.fillna(y.mean())

    # ---------------- LINEAR REGRESSION MODEL ----------------
    X_matrix = np.column_stack(
        [np.ones(len(X))] + [X[col].values for col in X.columns]
    )
    y_vector = y.values

    weights = np.linalg.pinv(X_matrix.T @ X_matrix) @ X_matrix.T @ y_vector

    # ---------------- USER INPUT ----------------
    st.subheader("Environmental & System Input Parameters")

    user_input = [1]

    for col in X.columns:
        unit = next(
            (UNIT_MAP[k] for k in UNIT_MAP if k in col.lower()),
            "units"
        )

        value = st.slider(
            label=f"{col} ({unit})",
            min_value=float(X[col].min()),
            max_value=float(X[col].max()),
            value=float(X[col].mean())
        )
        user_input.append(value)

    # ---------------- PREDICTION ----------------
    if st.button("Predict Power Generation"):
        user_array = np.array(user_input)
        prediction = user_array @ weights

        st.success(
            f"Predicted Solar Power Generated: {prediction:.2f} {target_unit}"
        )